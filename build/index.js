// Generated by CoffeeScript 1.12.2
var Depends, configure,
  hasProp = {}.hasOwnProperty,
  slice = [].slice,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Depends = (function() {
  function Depends(props) {
    var key, val;
    for (key in props) {
      if (!hasProp.call(props, key)) continue;
      val = props[key];
      this[key] = val;
    }
    if (this.DEFAULT_TIMEOUT == null) {
      this.DEFAULT_TIMEOUT = 10000;
    }
    if (this.Error == null) {
      this.Error = Error;
    }
    if (this.Promise == null) {
      this.Promise = Promise;
    }
    if (this.$object == null) {
      this.$object = {
        keys: function(object) {
          var results;
          if (Object.keys != null) {
            return Object.keys(object);
          }
          results = [];
          for (key in object) {
            if (!hasProp.call(object, key)) continue;
            results.push(key);
          }
          return results;
        },
        assign: function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if (Object.assign != null) {
            return Object.assign.apply(Object, args);
          }
          return args.reduce(function(memo, props) {
            for (key in props) {
              if (!hasProp.call(props, key)) continue;
              val = props[key];
              memo[key] = val;
            }
            return memo;
          });
        },
        entries: function(object) {
          var results;
          if (Object.entries != null) {
            return Object.entries(object);
          }
          results = [];
          for (key in object) {
            if (!hasProp.call(object, key)) continue;
            val = object[key];
            results.push([key, val]);
          }
          return results;
        }
      };
    }
    if (this.$promise == null) {
      this.$promise = {
        resolve: (function(_this) {
          return function(value) {
            if (_this.Promise.resolve != null) {
              return _this.Promise.resolve(value);
            }
            return new _this.Promise(function(resolve) {
              return resolve(value);
            });
          };
        })(this)
      };
    }
  }

  return Depends;

})();

configure = function(props) {
  var $object, $promise, ComponentDependencyNotDefined, ComponentHasCircularDependency, ComponentNotDefined, ComponentTimedOut, Container, DEFAULT_TIMEOUT, DependsNotParseable, Error, Exception, FactoryNotValid, Promise, depends, ref;
  ref = depends = new Depends(props), DEFAULT_TIMEOUT = ref.DEFAULT_TIMEOUT, Error = ref.Error, Promise = ref.Promise, $object = ref.$object, $promise = ref.$promise;
  Exception = (function(superClass) {
    extend(Exception, superClass);

    function Exception(payload) {
      Exception.__super__.constructor.call(this);
      this.name = this.constructor.name;
      this.payload = payload;
      this.message = this.getMessage(payload);
      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(this, this.constructor);
      }
    }

    return Exception;

  })(Error);
  ComponentHasCircularDependency = (function(superClass) {
    extend(ComponentHasCircularDependency, superClass);

    function ComponentHasCircularDependency() {
      return ComponentHasCircularDependency.__super__.constructor.apply(this, arguments);
    }

    ComponentHasCircularDependency.prototype.getMessage = function(arg) {
      var key, stack, str;
      key = arg.key, stack = arg.stack;
      str = [key].concat(stack).join(' < ');
      return "Component '" + key + "' has circular dependency '" + str + "'";
    };

    return ComponentHasCircularDependency;

  })(Exception);
  ComponentDependencyNotDefined = (function(superClass) {
    extend(ComponentDependencyNotDefined, superClass);

    function ComponentDependencyNotDefined() {
      return ComponentDependencyNotDefined.__super__.constructor.apply(this, arguments);
    }

    ComponentDependencyNotDefined.prototype.getMessage = function(arg) {
      var key, stack;
      key = arg.key, stack = arg.stack;
      return "Component '" + stack[0] + "' dependency not defined '" + key + "'";
    };

    return ComponentDependencyNotDefined;

  })(Exception);
  ComponentNotDefined = (function(superClass) {
    extend(ComponentNotDefined, superClass);

    function ComponentNotDefined() {
      return ComponentNotDefined.__super__.constructor.apply(this, arguments);
    }

    ComponentNotDefined.prototype.getMessage = function(arg) {
      var key;
      key = arg.key;
      return "Component '" + key + "' is not defined";
    };

    return ComponentNotDefined;

  })(Exception);
  DependsNotParseable = (function(superClass) {
    extend(DependsNotParseable, superClass);

    function DependsNotParseable() {
      return DependsNotParseable.__super__.constructor.apply(this, arguments);
    }

    DependsNotParseable.prototype.getMessage = function(arg) {
      var depends;
      depends = arg.depends;
      return "Cannot parse '" + depends + "'\n" + (JSON.stringify(depends));
    };

    return DependsNotParseable;

  })(Exception);
  ComponentTimedOut = (function(superClass) {
    extend(ComponentTimedOut, superClass);

    function ComponentTimedOut() {
      return ComponentTimedOut.__super__.constructor.apply(this, arguments);
    }

    ComponentTimedOut.prototype.getMessage = function(arg) {
      var key, ref1, timeout;
      ref1 = arg != null ? arg : {}, key = ref1.key, timeout = ref1.timeout;
      return "Component '" + key + "' timed out after " + (timeout / 1000) + "s";
    };

    return ComponentTimedOut;

  })(Exception);
  FactoryNotValid = (function(superClass) {
    extend(FactoryNotValid, superClass);

    function FactoryNotValid() {
      return FactoryNotValid.__super__.constructor.apply(this, arguments);
    }

    FactoryNotValid.prototype.getMessage = function(arg) {
      var key;
      key = arg.key;
      return "Component `" + key + "` factory not valid.";
    };

    return FactoryNotValid;

  })(Exception);
  Container = (function() {
    Container.prototype.definitions = null;

    Container.prototype.promises = null;

    Container.prototype.timeout = null;

    function Container(props) {
      $object.assign(this, props);
      if (this.definitions == null) {
        this.definitions = {};
      }
      if (this.promises == null) {
        this.promises = {};
      }
      if (this.timeout == null) {
        this.timeout = DEFAULT_TIMEOUT;
      }
    }

    Container.prototype.define = function() {
      var args, definition, definitions, factory, key, type, types, val;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      type = function(n) {
        var t;
        t = typeof args[n];
        if (Array.isArray(args[n])) {
          return 'array';
        }
        if (args[n] === null) {
          return 'null';
        }
        if (t && (args[n].factory != null)) {
          return 'definition';
        }
        return t;
      };
      types = args.map(function(val, i) {
        return type(i);
      }).join(', ');
      if (types === 'object') {
        definitions = args[0];
        for (key in definitions) {
          if (!hasProp.call(definitions, key)) continue;
          val = definitions[key];
          this.define(key, val);
        }
        return;
      }
      if (types === 'string, definition') {
        key = args[0], definition = args[1];
        this.definitions[key] = definition;
        return;
      }
      if (types === 'string, function') {
        key = args[0], factory = args[1];
        this.definitions[key] = {
          factory: factory
        };
        return;
      }
      if (types === 'string, array, function' || types === 'string, string, function' || types === 'string, object, function' || types === 'string, function, function') {
        key = args[0], depends = args[1], factory = args[2];
        this.definitions[key] = {
          depends: depends,
          factory: factory
        };
        return;
      }
      throw Error("Invalid arguments for #define: " + (JSON.stringify(args)));
    };

    Container.prototype.override = function(overrides) {
      var key, ref1, results, val;
      if (overrides == null) {
        overrides = {};
      }
      ref1 = this.definitions;
      results = [];
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        val = ref1[key];
        results.push($object.assign(val, overrides[key]));
      }
      return results;
    };

    Container.prototype.parse = function(depends) {
      var type;
      if (depends == null) {
        return [];
      }
      type = Array.isArray(depends) ? 'array' : typeof depends;
      switch (type) {
        case 'function':
          return this.parseFunction(depends);
        case 'string':
          return this.parseString(depends);
        case 'array':
          return this.parseArray(depends);
        case 'object':
          return this.parseObject(depends);
        default:
          throw new DependsNotParseable({
            depends: depends
          });
      }
    };

    Container.prototype.parseString = function(depends) {
      var _, alias, key, pattern, ref1, ref2;
      pattern = /^(.+)\sas\s(.+)$/;
      ref2 = (ref1 = pattern.exec(depends)) != null ? ref1 : [null, depends, depends], _ = ref2[0], key = ref2[1], alias = ref2[2];
      return [
        {
          key: key,
          alias: alias
        }
      ];
    };

    Container.prototype.parseArray = function(depends) {
      return depends.map((function(_this) {
        return function(str) {
          return _this.parseString(str)[0];
        };
      })(this));
    };

    Container.prototype.parseObject = function(depends) {
      return $object.entries(depends).map((function(_this) {
        return function(arg) {
          var alias, key;
          alias = arg[0], key = arg[1];
          if (typeof key !== 'string') {
            key = alias;
          }
          return {
            key: key,
            alias: alias
          };
        };
      })(this));
    };

    Container.prototype.parseFunction = function(depends) {
      return this.parseArray($object.keys(this.definitions).reduce(depends, []));
    };

    Container.prototype.resolve = function(depends) {
      return this.resolveSchema(this.parse(depends));
    };

    Container.prototype.resolveSchema = function(schema) {
      var reduceFn;
      reduceFn = (function(_this) {
        return function(memo, arg) {
          var alias, key;
          key = arg.key, alias = arg.alias;
          return memo.then(function(values) {
            return _this.resolveComponent(key).then(function(value) {
              var obj;
              return $object.assign(values, (
                obj = {},
                obj["" + (alias != null ? alias : key)] = value,
                obj
              ));
            });
          });
        };
      })(this);
      return schema.reduce(reduceFn, $promise.resolve({}));
    };

    Container.prototype.createComponentPromise = function(key) {
      var factory, ref1, schema;
      ref1 = this.definitions[key], factory = ref1.factory, depends = ref1.depends;
      schema = this.parse(depends);
      return this.resolveSchema(schema).then((function(_this) {
        return function(params) {
          return new Promise(function(resolve, reject) {
            var arity, hasParams, resolver;
            resolver = function(error, result) {
              if (error != null) {
                return reject(error);
              }
              return resolve(result);
            };
            resolver.resolve = resolve;
            resolver.reject = reject;
            arity = factory.length;
            hasParams = !!schema.length;
            if (arity === 0 && !hasParams) {
              return resolve(factory());
            }
            if (arity === 1 && hasParams) {
              return resolve(factory(params));
            }
            if (arity === 1 && !hasParams) {
              return factory(resolver);
            }
            if (arity === 2 && hasParams) {
              return factory(params, resolver);
            }
            throw new FactoryNotValid({
              key: key
            });
          });
        };
      })(this));
    };

    Container.prototype.timeoutComponentPromise = function(key, promise, timeout) {
      return new Promise(function(resolve, reject) {
        var clearsTimeout, onRejected, onResolved, onTimeout, timeoutId;
        onTimeout = function() {
          reject(new ComponentTimedOut({
            key: key
          }));
          return resolve = reject = function() {};
        };
        clearsTimeout = function(timeoutId, fn) {
          return function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            fn.apply(null, args);
            clearTimeout(timeoutId);
            return resolve = reject = function() {};
          };
        };
        timeoutId = setTimeout(onTimeout, timeout);
        onResolved = clearsTimeout(timeoutId, function(result) {
          return resolve(result);
        });
        onRejected = clearsTimeout(timeoutId, function(error) {
          return reject(error);
        });
        return promise.then(onResolved, onRejected);
      });
    };

    Container.prototype.resolveComponent = function(key) {
      var promise, ref1, ref2, timeout;
      if (this.promises[key] != null) {
        return this.promises[key];
      }
      this.validate(key);
      timeout = (ref1 = (ref2 = this.definitions[key].timeout) != null ? ref2 : this.timeout) != null ? ref1 : DEFAULT_TIMEOUT;
      promise = this.createComponentPromise(key);
      return this.promises[key] = this.timeoutComponentPromise(key, promise, timeout);
    };

    Container.prototype.validate = function(key, stack) {
      if (stack == null) {
        stack = [];
      }
      if (indexOf.call(stack, key) >= 0) {
        throw new ComponentHasCircularDependency({
          key: key,
          stack: stack
        });
      }
      if ((this.definitions[key] == null) && stack.length) {
        throw new ComponentDependencyNotDefined({
          key: key,
          stack: stack
        });
      }
      if ((this.definitions[key] == null) && !stack.length) {
        throw new ComponentNotDefined({
          key: key
        });
      }
      depends = this.definitions[key].depends;
      return this.parse(depends).forEach((function(_this) {
        return function(dep) {
          return _this.validate(dep.key, [key].concat(stack));
        };
      })(this));
    };

    Container.prototype.validateAll = function() {
      var key, ref1, results;
      ref1 = this.definitions;
      results = [];
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        results.push(this.validate(key));
      }
      return results;
    };

    return Container;

  })();
  return {
    Exception: Exception,
    ComponentHasCircularDependency: ComponentHasCircularDependency,
    ComponentDependencyNotDefined: ComponentDependencyNotDefined,
    ComponentNotDefined: ComponentNotDefined,
    ComponentTimedOut: ComponentTimedOut,
    FactoryNotValid: FactoryNotValid,
    Container: Container,
    configure: configure,
    depends: depends
  };
};

exports.configure = configure;

exports.Depends = Depends;

//# sourceMappingURL=index.js.map
